{
  "hash": "89e9dad74d8a337b95b7717fd19145cc",
  "result": {
    "markdown": "---\ntitle: \"Linear & Nonlinear regression\"\nauthor: \"Jonathan West\"\ndate: \"2023-11-23\"\ncategories: [Regression, code]\ndescription: \"This is a blog post demonstrating linear and nonlinear regression.\"\nformat:\n    html:\n        code-tools: true\n---\n\n## Introduction\nLinear and nonlinear regression are important foundational techniques in machine learning and statistics used to model the relationship between independent and dependent variables in data. \nLinear regression is an approach to model the relationship between a development variable and one or more explanatory variables by fitting a linear equation to observed data. \nNonlinear regression is a form of regression analysis in which data is fit to a model and then expressed as a mathematical function. \nNonlinear regression allows for more complex relationships between variables, and is essential for identifying and modeling patterns in the data that are nonlinear. \n\nIn today's blog post, we will be exploring linear and nonlinear regression using Python, with the scikit-learn California housing dataset.\n\n## Linear regression\nAs mentioned above, linear regression is a linear approach to modeling the relationship between a development variable and one or more explanatory variables.\nWe can use linear regression to predict the value of future dependent variable observations, by modeling on recorded data.\n\nLet's start by conducting simple linear regression on some randomly generated data. We will use the `numpy` library to create a dataset randomly distributed around the line `y = 2.5x + 1.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.linear_model import LinearRegression\n\n# Generate sample data\nnp.random.seed(42)\nX = 2.5 * np.random.randn(100) + 2  # Array of 100 values centered at 2 stddev = 3\ny = 0.5 * X + np.random.randn(100)  # Linear equation y = 0.5x, with added random noise\nplt.scatter(X, y, color='blue')\nplt.title('Simple Linear Regression')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-2-output-1.png){width=587 height=449}\n:::\n:::\n\n\nHere we have generated a dataset of 100 points, with a linear relationship y = 0.5x - 3, and random noise added to the data.\nNow we will conduct simple linear regression to fit a line to the data, and make predictions.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# Create a linear regression model and fit it to the data\n# Find means of x & y\nx_mean = np.mean(X)\ny_mean = np.mean(y)\n\n# Calculate terms needed for the numerator and denominator of predicted slope \nnumerator = np.sum((X - x_mean) * (y - y_mean))\ndenominator = np.sum((X - x_mean) ** 2)\n\n# Calculate the linear equation coefficients\nslope = numerator / denominator\nintercept = y_mean - (slope * x_mean)\n\n# Create predicted line\ny_pred = slope * X + intercept\n\n# Plot the data points and the predicted line\nplt.scatter(X, y, color='green')\nlabel = f'y = {slope:.2f}x + {intercept:.2f}'\nplt.plot(X, y_pred, color='blue')\nplt.title('Simple Linear Regression: ' + label)\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-1.png){width=587 height=449}\n:::\n:::\n\n\nWe can see that the line of best fit is very close to the original line, and the predicted line is a good fit for the data. \nThis is a simple toy example of linear regression, which is based in basic algebra and uses the least squares method to find the line of best fit.\nThe example worked quite nicely because the data was generated with a linear relationship, with some random noise added.\nNow, lets use the concept of regression to predict the median house value in Californian districts, using the California housing dataset.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom sklearn.datasets import fetch_california_housing\n\nhousing_data = fetch_california_housing()\nhd = pd.DataFrame(housing_data.data, columns=housing_data.feature_names)\nhd[housing_data.target_names[0]] = housing_data.target  # Include target variable in dataframe: median house value\n\n# Display first 5 rows of data\nhd.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>MedInc</th>\n      <th>HouseAge</th>\n      <th>AveRooms</th>\n      <th>AveBedrms</th>\n      <th>Population</th>\n      <th>AveOccup</th>\n      <th>Latitude</th>\n      <th>Longitude</th>\n      <th>MedHouseVal</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>8.3252</td>\n      <td>41.0</td>\n      <td>6.984127</td>\n      <td>1.023810</td>\n      <td>322.0</td>\n      <td>2.555556</td>\n      <td>37.88</td>\n      <td>-122.23</td>\n      <td>4.526</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>8.3014</td>\n      <td>21.0</td>\n      <td>6.238137</td>\n      <td>0.971880</td>\n      <td>2401.0</td>\n      <td>2.109842</td>\n      <td>37.86</td>\n      <td>-122.22</td>\n      <td>3.585</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>7.2574</td>\n      <td>52.0</td>\n      <td>8.288136</td>\n      <td>1.073446</td>\n      <td>496.0</td>\n      <td>2.802260</td>\n      <td>37.85</td>\n      <td>-122.24</td>\n      <td>3.521</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>5.6431</td>\n      <td>52.0</td>\n      <td>5.817352</td>\n      <td>1.073059</td>\n      <td>558.0</td>\n      <td>2.547945</td>\n      <td>37.85</td>\n      <td>-122.25</td>\n      <td>3.413</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>3.8462</td>\n      <td>52.0</td>\n      <td>6.281853</td>\n      <td>1.081081</td>\n      <td>565.0</td>\n      <td>2.181467</td>\n      <td>37.85</td>\n      <td>-122.25</td>\n      <td>3.422</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nAs usual, we will start by exploring the data. We can see that there are 8 features, and 1 target variable: median house value. \nOur goal is to predict the median house value based on the other features.\nLets start by looking at the distribution of the target variable, median house value in hundreds of thousands of dollars.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Plot the distribution of the target variable\nsns.distplot(hd[housing_data.target_names[0]])\nplt.title('Distribution of median house value')\nplt.xlabel('Median house value')\nplt.ylabel('Frequency')\nplt.show()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/tmp/ipykernel_13195/3123216598.py:2: UserWarning: \n\n`distplot` is a deprecated function and will be removed in seaborn v0.14.0.\n\nPlease adapt your code to use either `displot` (a figure-level function with\nsimilar flexibility) or `histplot` (an axes-level function for histograms).\n\nFor a guide to updating your code to use the new functions, please see\nhttps://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751\n\n  sns.distplot(hd[housing_data.target_names[0]])\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-5-output-2.png){width=589 height=449}\n:::\n:::\n\n\nThe median house value is distributed roughly normally, with a mean of around 2.1 and a slight right skew.\nNow lets look at the correlation between the target variable and the other features.\nWe will create scatterplots of the target variable against each feature, and calculate the correlation coefficient.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Assuming df is your DataFrame with the 9 numerical features\n# and \"MedHouseValue\" is the target feature\n# Select the 8 numerical features you want to plot\nfeatures_to_plot = housing_data.feature_names\n\n# Create a new figure with 8 subplots\nfig, axes = plt.subplots(4, 2, figsize=(8, 16))\nfig.suptitle(\"Scatterplots of Numerical Features vs. Median House Value\", size=14)\n\n# Flatten the 2D array of subplots into a 1D array\naxes = axes.flatten()\n\n# Loop through the selected features and create scatterplots\nfor i, feature in enumerate(features_to_plot):\n    ax = axes[i]\n    ax.scatter(hd[feature], hd[\"MedHouseVal\"], alpha=0.5)\n    ax.set_xlabel(feature)\n    ax.set_ylabel(\"Median House Value (in $100,000s)\")\n\n# Adjust the layout and display\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-6-output-1.png){width=757 height=1510}\n:::\n:::\n\n\nAs we can see from these graphs, most of the features lack a strong linear relationship with the target variable. The strongest linear relationship is between median income and median house value, which makes sense. Higher income areas tend to have higher house prices.\n\nIn any case, lets use linear regression to predict the median house value based on median income, which seems to be the most promising feature.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nfrom sklearn.linear_model import LinearRegression\n\n# Simple linear regression\nX = hd['MedInc'].values\ny = hd['MedHouseVal'].values\n# reshape X\nX = X.reshape(-1, 1)\n\n# Create linear regression model & fit to data\nmodel = LinearRegression()\nmodel.fit(X, y)\n\n# Obtain equation coefficients, & predict y values\nslope = model.coef_\nintercept = model.intercept_\ny_pred = model.predict(X)\n\n# Display our results\nplt.scatter(X, y, color='green')  # actual points\nplt.plot(X, y_pred, color='blue')  # predicted line\nplt.title('House value based on household income: ' + f'y = {slope[0]:.2f}x + {intercept:.2f}')\nplt.xlabel('Median income')\nplt.ylabel('Median house value')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-7-output-1.png){width=576 height=449}\n:::\n:::\n\n\nAs we can see, the line of best fit roughly correlates to the data, but there are many outliers. Let's calculate the mean squared error to see how well our model fits the data.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Compute mean squared error\nmse = np.mean((y_pred - y) ** 2)\nprint(f'Mean squared error: {mse}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMean squared error: 0.7011311502929527\n```\n:::\n:::\n\n\nIn this case the mean squared error is relatively high, which we could have expected simply by looking at the graph. \nPerhaps the data is not linearly related, and we should try a nonlinear regression model instead. We can now move on to nonlinear regression.\n\n## Nonlinear regression\nNonlinear regression is a form of regression analysis in which data is fit to a model and then expressed as a mathematical function. It is a fundamental concept in machine learning, and is used to model complex relationships between variables.\n\nLet's apply nonlinear regression to the California housing dataset, and see if we can improve our predictions of median house value.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nfrom sklearn.preprocessing import PolynomialFeatures\n\n# Obtain data again\nX2 = hd['MedInc'].values\ny2 = hd['MedHouseVal'].values\n\n# Reshape X\nX2 = X2.reshape(-1, 1)\n\n# Create Polynomial Features\ndegree = 2  # You can adjust the degree of the polynomial\ndef show_nonlin_regression(X, y, degree):\n    poly_features = PolynomialFeatures(degree=degree)\n    X_poly = poly_features.fit_transform(X)\n\n    # Create and fit Polynomial Regression model\n    poly_model = LinearRegression()\n    poly_model.fit(X_poly, y)\n\n    # Predict y values\n    y_pred = poly_model.predict(X_poly)\n\n    # Sort X and y_pred for better visualization\n    sort_idx = np.argsort(X[:, 0])\n    X_sorted = X[sort_idx]\n    y_pred_sorted = y_pred[sort_idx]\n\n    # Display results\n    plt.scatter(X, y, color='green', label='Actual data')\n    plt.plot(X_sorted, y_pred_sorted, color='blue', label='Polynomial Regression')\n    plt.title(f'House value based on household income (Polynomial Regression - Degree {degree})')\n    plt.xlabel('Median income')\n    plt.ylabel('Median house value')\n    plt.legend()\n    plt.show()\n    return y_pred\n\ny_pred2 = show_nonlin_regression(X2, y2, degree)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-9-output-1.png){width=634 height=449}\n:::\n:::\n\n\nThis time it appears the regression model fits the data slightly better, but not by much.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Compute mean squared error\nmse = np.mean((y_pred2 - y2) ** 2)\nprint(f'Mean squared error: {mse}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMean squared error: 0.695037253723973\n```\n:::\n:::\n\n\nAs you can see, the mean squared error is slightly lower than the linear regression model, but still quite high. Let's try a higher degree polynomial.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# Obtain data again\nX3 = hd['MedInc'].values\ny3 = hd['MedHouseVal'].values\nX3 = X3.reshape(-1, 1)\ny_pred3 = show_nonlin_regression(X3, y3, 3)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-11-output-1.png){width=634 height=449}\n:::\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# Compute mean squared error\nmse = np.mean((y_pred2 - y2) ** 2)\nprint(f'Mean squared error: {mse}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMean squared error: 0.695037253723973\n```\n:::\n:::\n\n\nYet again, the model doesn't fit the data incredibly well, and the mean squared error is still quite high. Additionally, it appears that the model is begginning to overfit the data, as the line of best fit is beginning to curve too much to fit the data.\nIt doesn't make sense for very high income areas to have somewhat lower house prices, yet the model predicts this.\nWith simple regression it is difficult to model the relationship between median income and median house value, as there are many other factors that affect house prices. The variance in house prices is likely due to other factors, such as location, house size, and age of the house.\nHowever, we have still illustrated how linear and nonlinear regression can be applied to predict the value of future dependent variable observations, by modeling on recorded data.\n\nLastly, let's try to predict the median house value based on the other features, using multiple linear regression.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error, r2_score\n\n# Prepare feature matrix and target \nX = hd.drop(columns=['MedHouseVal'])  # Use all columns except 'MedHouseVal' as features\ny = hd['MedHouseVal']\n\n# Split dataset into training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Create and fit multiple linear regression model\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\n# Interpret the model coefficients\ncoefficients = pd.DataFrame({'Feature': X_train.columns, 'Coefficient': model.coef_})\nintercept = model.intercept_\nprint(\"Intercept:\", intercept)\nprint(\"Coefficients:\")\nprint(coefficients)\n\n# Make predictions on the test set\ny_pred = model.predict(X_test)\n\n# Evaluate the model\nmse = mean_squared_error(y_test, y_pred)\nr2 = r2_score(y_test, y_pred)\n\nprint(\"Mean Squared Error (MSE):\", mse)\nprint(\"R-squared (R2) Score:\", r2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIntercept: -37.02327770606409\nCoefficients:\n      Feature  Coefficient\n0      MedInc     0.448675\n1    HouseAge     0.009724\n2    AveRooms    -0.123323\n3   AveBedrms     0.783145\n4  Population    -0.000002\n5    AveOccup    -0.003526\n6    Latitude    -0.419792\n7   Longitude    -0.433708\nMean Squared Error (MSE): 0.5558915986952444\nR-squared (R2) Score: 0.5757877060324508\n```\n:::\n:::\n\n\nAs we can see, the multiple linear regression model fits the data much better than the simple linear regression model, and the mean squared error is much lower. \nIncorporating multiple features allows us to more closely model the real life relationships between these variables.\nNow lets use a final visualization for the work we have done.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# Plot actual vs predicted vals\nplt.figure(figsize=(8, 6))\nplt.scatter(y_test, y_pred)\nplt.xlabel('Actual Values')\nplt.ylabel('Predicted Values')\nplt.title('Actual vs. Predicted Values')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-14-output-1.png){width=659 height=523}\n:::\n:::\n\n\nThere does appear to be a linear relationship between the actual and predicted values, following the equation y=x. This is a good sign, as it means our model is predicting the values reasonably. \nHowever we can see that the success of the regression was still limited by our choice of model, data features, and potentially outliers in the data.\n\n# Conclusion\nIn this blog post we have explored linear and nonlinear regression using Python, with the scikit-learn California housing dataset. Linear regression is a linear approach to modeling the relationship between a development variable and one or more explanatory variables, while nonlinear regression is a more general regression analysis in which data is fit to a model and then expressed as a mathematical function. \nRegression is a foundational topic to machine learning, and I hope this blog post has helped you understand some of the basics of regression and inspired you to learn more.\n\n## Sources used\n1. https://realpython.com/linear-regression-in-python/\n2. https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.plotting.scatter_matrix.html\n3. https://github.com/ageron/handson-ml3\n4. https://www.investopedia.com/terms/m/mlr.asp\n5. https://medium.com/machine-learning-with-python/multiple-linear-regression-implementation-in-python-2de9b303fc0c\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}